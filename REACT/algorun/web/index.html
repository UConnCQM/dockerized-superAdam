<!DOCTYPE html>
<html lang="en">
<head>
<link rel="stylesheet" href="/css/bootstrap.min.css">
<link rel="stylesheet" href="/css/bootstrap-theme.min.css">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Bootstrap 101 Template</title>
<style type="text/css"> 
body {
	padding-top: 50px;
}
.starter-template {
	padding: 40px 15px;
	text-align: justify;
}
</style>
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="#">Algorun</a>
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav">
				<li class="active"><a href="#">Home</a></li>
				<li><a href="#run">Run</a></li>
				<li><a href="#config">Configuration</a></li>
				<li><a href="#doc">Documentation</a></li>
				<li><a href="#about">About</a></li>
			</ul>
		</div><!--/.nav-collapse -->
	</div>
</nav>

<div class="container">
	<div class="starter-template">
		<h1>REACT<br/>Evolutionary Algorithm for Discrete Dynamical System Optimization</h1>
			<h2><a name="run">Run</a></h2>
			<p>Enter input JSON below and hit the RUN button</p>
			<form id="run_form" action="/do/run">
				<p align="right"><button id="reset_computation" style="height:20px;width:100px;padding:0px;font-size:80%;" type="button" class="btn btn-default">reset computation</button>&nbsp;&nbsp;<button id="populate_input" style="height:20px;width:150px;padding:0px;font-size:80%;" type="button" class="btn btn-info">fill form with JSON example</button></p>
			<textarea name="input" id="input_data" class="form-control" rows="8" style="font-size:80%;"></textarea>
				<br/><p align="center"><button style="width:200px;align:right;" id="run_button" type="submit" class="btn btn-success">RUN</button></p>
			</form>
				<div>
					<p>Computation result</p>
					<textarea id="output_data" class="form-control" rows=8 style="font-size:80%;"></textarea>
				</div>
			<h2><a name="config">Configuration</a></h2>
			<p>No specific configuration available.</p>
			<h2><a name="doc">Documentation</a></h2>
				<h3>HTTP POST /do/run</h3>
					<h4>parameters</h4>
					<ul>
						<li><b>input</b> the input for REACT in standardized JSON format (see example below).</li>
					</ul>
					<h4>example JSON input</h4>
					<pre><code id="code_example_1" class="language-javascript" data-lang="javascript">{
  "task": {
      "method": {
          "description": "this is the reverse engineering method that uses an evolutionary algorithm as optimization method",
          "id": "REACT",
          "type": "reverseEngineering",
          "arguments": [
              { "name": "HammingPolyWeight", "value": 0.5 },
              { "name": "ComplexityWeight", "value": 0.2 },
              { "name": "RevEngWeight", "value": 0.2 },
              { "name": "BioProbWeight", "value": 0.1 },
              { "name": "HammingModelWeight", "value": 0.35 },
              { "name": "PolyScoreWeight", "value": 0.65 },
              { "name": "GenePoolSize", "value": 100 },
              { "name": "NumCandidates", "value": 55 },
              { "name": "NumParentsToPreserve", "value": 5 },
              { "name": "MaxGenerations", "value": 100 },
              { "name": "StableGenerationLimit", "value": 50 },
              { "name": "MutateProbability", "value": 0.5 },
              {
                "name": "priorBiologicalNetwork",
                "value": [
                    [1,0.5,0.3,0],
                    [0,1,0.5,1],
                    [1,0,0,1],
                    [1,0,0.7,1]
                  ]
              }
            ]
        },
      "input": [
          {
            "description": "Polynomial model generated by a previously applied reverse-engineering method",
            "fieldCardinality": 2,
            "name": "priorReverseEngineeringNetwork",
            "type": "model",
            "variableScores": [
                {
                  "sources": [
                      { "score": 0.5, "source": "x1" },
                      { "score": 1, "source": "x2" },
                      { "score": 1, "source": "x3" },
                      { "score": 1, "source": "x4" }
                    ],
                  "target": "x1"
                },
                {
                  "sources": [
                      { "score": 1, "source": "x2" },
                      { "score": 1, "source": "x4" }
                    ],
                  "target": "x2"
                },
                {
                  "sources": [
                      { "score": 0.5, "source": "x1" },
                      { "score": 0.5, "source": "x2" }
                    ],
                  "target": "x3"
                },
                {
                  "sources": [
                      { "score": 0.33, "source": "x2" },
                      { "score": 0.66, "source": "x3" }
                    ],
                  "target": "x4"
                }
              ]
          },
          {
            "description": "Polynomial model generated by a previously applied reverse-engineering method",
            "fieldCardinality": 2,
            "name": "priorModel",
            "type": "model",
            "updateRules": [
                {
                  "functions": [
                      {
                        "inputVariables": ["x1","x2"],
                        "polynomialFunction": "x1*x2"
                      }
                    ],
                  "target": "x1"
                },
                {
                  "functions": [
                      {
                        "inputVariables": ["x1"],
                        "polynomialFunction": "x1+1"
                      },
                      {
                        "inputVariables": ["x1","x2"],
                        "polynomialFunction": "x1*x2"
                      }
                    ],
                  "target": "x2"
                },
                {
                  "functions": [
                      {
                        "inputVariables": ["x1","x2","x3"],
                        "polynomialFunction": "x3^2+x1"
                      }
                    ],
                  "target": "x3"
                },
                {
                  "functions": [
                      {
                        "inputVariables": ["x1","x3"],
                        "polynomialFunction": "x3^2+x1+x2"
                      }
                    ],
                  "target": "x4"
                }
              ]
          },
          {
            "timeSeriesData": [
                {
                  "index": [],
                  "matrix": [
                      [1,0,0,0],
                      [0,1,0,1],
                      [1,1,0,0]
                    ],
                  "name": "wildtype experiment 1"
                },
                {
                  "index": [],
                  "matrix": [
                      [1,1,0,0],
                      [0,0,0,1],
                      [1,0,0,0]
                    ],
                  "name": "wildtype experiment 2"
                },
                {
                  "index": [1],
                  "matrix": [
                      [0,0,0,0],
                      [0,0,0,1],
                      [0,1,0,0],
                      [0,0,0,1]
                    ],
                  "name": "knockout experiment 1"
                },
                {
                  "index": [3],
                  "matrix": [
                      [0,1,0,0],
                      [0,1,0,1],
                      [0,1,0,1],
                      [0,0,0,0]
                    ],
                  "name": "knockout experiment 2"
                },
                {
                  "index": [2],
                  "matrix": [
                      [1,0,0,0],
                      [0,0,0,1],
                      [1,0,0,1],
                      [0,0,0,0]
                    ],
                  "name": "knockout experiment 3"
                }
              ],
            "type": "timeSeries"
          }
        ]
    }
}</code>
					</pre>	
					<h4>example JSON output</h4>
					<pre>
<code class="language-javascript" data-lang="javascript">{
      "output": [
          {
            "description": "Polynomial model generated by a previously applied reverse-engineering method",
            "fieldCardinality": 2,
            "name": "reverseEngineeringOutputModel",
            "type": "model",
            "variableScores": [
                {
                  "target": "x1",
                  "sources": [
                      { "score": 1, "source": "x1" },
                      { "score": 1, "source": "x2" },
                      { "score": 1, "source": "x3" }
                    ]

                },
                {
                  "target": "x2",
                  "sources": [
                      { "score": 1, "source": "x2" },
                      { "score": 1, "source": "x4" }
                    ]
                },
                {
                  "target": "x3",
                  "sources": [
                      { "score": 1, "source": "x1" }
                    ]
                },
                {
                  "target": "x4",
                  "sources": [
                      { "score": 1, "source": "x3" },
                      { "score": 0.5, "source": "x4" }
                    ]
                }
              ],
            "updateRules": [
                {
                  "target": "x1",
                  "functions": [
                      {
                        "inputVariables": ["x1","x2","x3","x4"],
                        "polynomialFunction": "x1*x2 + x1 + x2 + x3*x4 + 1",
			"score": "Average(H+C+R+B)"
                      },
                      {
                        "inputVariables": ["x1","x2","x3","x4"],
                        "polynomialFunction": "x1*x3 + x1*x4 + x2*x3 +x4 +0",
			"score": "Average(H+C+R+B)"
                      }
                    ]
                },
                {
                  "target": "x2",
                  "functions": [
                      {
                        "inputVariables": ["x2","x4"],
                        "polynomialFunction": "x2*x4 + x4 + 0",
			"score": "Average(H+C+R+B)"
                      },
                      {
                        "inputVariables": ["x2","x4"],
                        "polynomialFunction": "x2 + x4 + 1",
			"score": "Average(H+C+R+B)"
                      }
                    ]
                },
                {
                  "target": "x3",
                  "functions": [
                      {
                        "inputVariables": ["x1"],
                        "polynomialFunction": "x1",
			"score": "Average(H+C+R+B)"
                      }
                    ]
                },
                {
                  "target": "x4",
                  "functions": [
                      {
                        "inputVariables": ["x3"],
                        "polynomialFunction": "x3 + 1",
			"score": "Average(H+C+R+B)"
                      },
                      {
                        "inputVariables": ["x3","x4"],
                        "polynomialFunction": "x3 + x4 + 1",
			"score": "Average(H+C+R+B)"
                      }
                    ]
                }
              ]
          }
        ]
}</code>
					</pre>
			<h2><a name="about">About</a></h2>
				<h3>About REACT</h3>
					<h4>Authors</h4>
					<p>Paola Vera-Licona &amp; John J. McGee Virginia Bioinformatics Institute at Virginia Tech</p>
					<p>The inference of gene regulatory networks (GRNs) from system-level experimental observations is at the heart of systems biology due to its centrality in gaining insight into the complex regulatory mechanisms in cellular systems. This includes the inference of both the network topology and dynamic mathematical models.</p>
					<p>This software contains a novel network inference algorithm within the algebraic framework of Boolean polynomial dynamical system (BPDS). The algorithm considers time series data, including that of perturbation experiments such as knock-out mutants and RNAi experiments. To infer the network topology and dynamic models, it allows for the incorporation of prior biological knowledge while being robust to significant levels of noise in the data used for inference. It uses an evolutionary algorithm for local optimization with an encoding of the mathematical models as BPDS.</p>
					<p>More info about REACT: <a target="_blank" href="http://www.paola-vera-licona.net/Software/EARevEng/REACT.html">http://www.paola-vera-licona.net/Software/EARevEng/REACT.html</a></p>
				<h3>About Algorun</h3>
					<h4>Author</h4>
					<p>Thibauld Favre</p>
					<p>Algorun is a platform where you can find already implemented and running algorithm, ready to use.</p>
					<p>More info about Algorun: <a target="_blank" href="mailto:thibauld@fastmail.com">thibauld@fastmail.com</a></p>
	</div>
</div>
<script src="/js/jquery-1.11.2.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/algorun.js"></script>
<script type="application/javascript">
//run();
</script>
</body>
</html>

